---
layout:     post
title:      "反应式设计模式 读后感"
subtitle:   ""
date:       2020-03-29 11:26:00
author:     "aguozhang"
header-img: "img/post-bg-2015.jpg"
tags:
    - 反应式 
    - 设计模式
    - 函数式
---

## 前言
了解反应式的一本入门书，大部分内容都曾见过，只是没有系统化。

不足之处在于尝试不够

翻译要吐槽一下，专有术语如果不知道怎么翻译成中文，就直接保留英文嘛，干嘛要自己发明呢

## 摘录

* 在自己的职业生涯中，我亲眼看到了弹性、松耦合、消息驱动的系统可带来巨大效益，与那些隐藏了分布式系统本质的传统方案相比更甚
* 必须对用户作出反应
* 必须对失败作出反应
* 必须对不同的负载情况作出反应
* 必须对输入作出反应
* 可维护性maintainability 可扩展性extensibility
* 利用并行性
* 通过并行化降低延迟
* 使用可组合的future改善并行性
* 即时响应性 
* 回弹性
* 弹性
* 消息驱动
* 不可变性
* 引用透明性
* 副作用
* 函数作为一等公民
* 对反应式设计的现有支持：
* 绿色线程
* 事件循环
* 通信顺序进程
* Future和Promise
* 反应式扩展工具包
* Actor模型
* 天然的异步性
* 通过监督实现容错性
* 位置透明性
* Actor内部无并发
* Erlang和Akka之间的不同
* 微言大义
* 事件是建立消息传递的基石：事实上，一个特定条件的触发（事件本身）捆绑了上下文信息-- 如某人在某时某地做了某事--并且被生产者以消息的形式传送。
* 消息
* 垂直伸缩
* 基于事件与基于消息
* 虽然我们已经确定了消息传递是一种非常有用的抽象，但我们还需要指出在处理消息时（不管是在邮局还是在计算机里）都可能发生的两个基本问题：
* 有时我们必须保证特定的、非常重要的信件的送达
* 如果消息发送的速率快于它们能够被送达的速率，那么消息就会在某处堆积起来，并最终导致系统崩溃或消息丢失
* 同步与异步
* 流量控制
* back pressure 回压
* 送达保证
* 作为消息的事件
* 消息天然就在表达事件，消息传递天然就在表达事件驱动的交互。
* 在最底层，计算机之间的交互是以消息形式进行的。
* 消息传递是任何种类的独立对象之间最天然的通信形式
* 位置透明性
* 透明化远程处理的谬误：最明显的问题是部分失败，性能期望
* 基于显式消息传递的纠正方案
* 分而治之
* 分层拆解问题
* 依赖与子模块
* 构建你自己的大公司
* 规范和测试的优点
* 水平扩展性和垂直伸缩性
* 原则性失败处理
* 所有权意味着承诺
* 向上委托失败处理变得十分必要
* 所有权隐含生命周期控制
* 所有级别上的回弹性
* 监督者一人出力，余者受益
* 有界一致性
* 分布式系统的某种定义是：一个各部分允许独立失败的系统。反应式设计的本质是分布式的：你想对相互隔离的组件进行建模，并且只通过位置透明的消息传递进行交互，从而建立具有回弹性的监督层级结构
* 分布式共识（distributed consensus)
* 封装模块纠正方案
* 根据事务边界对数据和行为进行分组
* 跨事务边界建模工作流
* 失败单元即一致性单元
* 分离职责
* 按需使用非确定性
* 始于天堂的自我放逐
* 函数式反应式编程
* 消息流
* 推动数据向前流动
* 模型化领域流程
* 认清回弹性的局限性
* 设计模式
* 测试反应式应用程序
* 弹性 回弹性 即时响应性
* 容错及恢复模式
* 简单组件模式
* 错误内核模式
* 放任崩溃模式
* 断路器模式
* 一个组件应该只做一件事情，并且完整做完
* 在监督层级中，将重要的应用程序状态或功能存留在根部附近，而将具有风险的操作委托给叶子节点
* 对于内部失败处理，优先选择完整重启组件
* 在失败时间延长时，通过断开与用户之间的连接来保护服务

* 复制模式
* 主动-被动复制模式
* 保持服务的多个副本运行在不同的位置，但在任何时刻，只接受对于其中一个位置的状态修改
* 多主复制模式
* 在不同位置上保持服务的多个副本，每处都可接受修改，并将所有修改在各个副本之间传播
* 基于共识的复制
* 主动-主动复制模式
* 在不同的地方持有服务的多份副本，并在所有副本上执行所有的修改操作

* 资源管理模式
* 资源封装模式
* 资源及其生命周期必须由一个组件负责
* 资源借贷模式
* 在不转让所有权的情况下，给予客户端对稀缺资源独占的临时访问权
* 复杂命令模式
* 向资源发送复合指令以避免过度使用网络
* 资源池模式
* 在资源的所有者后面隐藏一个弹性资源池
* 托管阻塞模式
* 阻塞资源需要慎重考虑并明确所有权

* 消息流模式
* 请求-响应模式
* 消息中包含一个用于接收响应的返回地址
* 消息自包含模式
* 每个消息都包含处理请求以及理解其响应需要的全部信息
* 询问模式
* 将产生响应的过程委托给专用的临时组件
* 转发流模式
* 让消息和消息尽可能直接地流向其目的地
* 聚合器模式
* 如果需要多个服务响应来计算服务的调用结果，可专门创建一个临时组件
* 事务序列模式
* 将耗时长的分布式事务切分为快速的本地事务，并通过补偿操作进行恢复，换言之：创建一个临时组件来专门管理分布在多个组件中一系列动作的执行过程
* saga
* 业务握手协议（或可靠投递模式）
* 在消息中包含标识符和/或序列信息，并在收到确认之前一直重试
* 流量控制模式
* 拉取模式
* 让消费者向生产者对数据的批量大小提出要求
* 托管队列模式
* 管理一条显示的输入队列，并对其填充级别予以反应、
* 丢弃模式
* 丢弃请求，比不受控制地失败更可靠
* 限流模式
* 根据与其他服务之间的约定来限制自己的输出速率
* 状态管理和持久化模式
* 领域对象模式
* 将业务领域逻辑与通信、状态管理分离
* 分片模式
* 基于各类独一无二并且稳定的对象属性，相应地将大量领域对象进行分组分片，从而水平扩展对它们的管理
* 事件溯源模式
* 仅通过应用事件来执行状态变更，并通过将事件存储在日志中来持久化状态变更
* 事件流模式
* 散布某个组件发出的事件，以便系统的其他部分可从中衍生知识
 



