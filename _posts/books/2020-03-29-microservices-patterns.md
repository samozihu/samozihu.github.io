---
layout:     post
title:      "微服务架构设计模式 读后感"
subtitle:   "一本实战型的书"
date:       2020-03-29 09:06:00
author:     "aguozhang"
header-img: "img/post-bg-2015.jpg"
tags:
    - microservice 
    - 微服务
    - 设计模式 
    - pattern
---


## 前言
实战性很强的一本书，内容全面。

## 摘录
* 要记住微服务不是解决所有问题的万能“银弹”
* 编写整洁的代码和使用自动化测试至关重要，因为这是现代软件开发的基础
* 关注微服务的本质，即服务的分解和定义，而不是技术，如容器和其他工具
* 确保你的服务松耦合，并且可以独立开发、测试和部署，不要搞成分布式单体，那将会是巨大的灾难
* 不能只是在技术上采用微服务架构，拥抱DEVOPS的原则和实践，在组织结构上实现跨职能的自治团队，这必不可少
* 要记住，实现微服务架构并不是你的目标，你的目标是加速大型复杂应用程序的开发
* Paas 十二原则
* 软件的架构设计，就是选择和取舍
* 良马难乘，然可以任重致远; 良才难令，然可以致君见尊
* 取舍之间
* 细节是魔鬼
* 未来已经到来，只是还没有平均分布
* 复杂事件处理CEP
* Food to go   => FTGO
* 什么是单体地狱
* 可维护性，可扩展性，可测试性
* 面向服务的架构，他们由松耦合和具有边界上下文的元素组成
* 扩展立方体
* 微服务架构使用服务作为模块化的单元
* 持续交付和持续部署是devops的一部分
* 服务可以独立扩展
* 吏好的容错性
* 更容易实验和采纳新的技术
* 架构设计的核心是决策
* 光环曲线
* 期望释放的顶峰
* 失望的山谷
* 生产力的高地
* it depends
* 作为软件开发社区的一员，需要克服我们情绪化的本能，找到一种讨论和应用技术的更好方法：模式
* 需求
* 结果上下文
* 相关模式
* 微服务之上：流程和组织
* 除了拥有正确的架构之外，成功的软件开发还需要在组织、开发和交付流程方面做一些工作
* 逆向的康威定律
* 用一匹马来拉法拉利跑车
* 微服务架构直接支持持续交付和持续部署
* 结束、失落和放弃
* 中立区
* 新的开始
* 架构很重要的原因是它决定了应用程序的质量属性或能力
* 软件架构的定义
* 关于架构风格的六边形
* 微服务架构是一种架构风格
* 服务是一个单一的、可独立部署的软件组成，它实现了一些有用的功能
* 服务的大小并不重要
* 第一步：定义系统操作
* 第二步：定义服务
* 第三步：定义服务api和协作方式
* 根据业务能力进行服务拆分
* 根据子域进行服务拆分
* DDD把领域模型的边界称为限界上下文(bounded context)
* 拆分服务原则：单一职责原则，闭包原则
* 难点：网络延迟， 同步进程间通信导致可用性降低，在服务之间维持数据一致性， 获取一致的数据视图，上帝类阻碍了拆分

* 微服务架构中的进程间通信
* 一对一
* 一对多
* 同步模式
* 异步模式
* 请求/响应
* 异步请求/响应
* 单向通知
* 发步/订阅方式
* 发布/异步响应方式
* 语义化版本控制
* 基于同步远程过程调用模式的通信
* REST成熟度模型
* 定义REST API => swagger
* graphQL, 旨在支持高效的数据获取
* grpc是rest的另一种替代方案
* 你可以使用protocol buffer编译器生成客户端的桩（stub,也称为存根）和服务端骨架(skeleton)
* 使用断路器模式处理局部故障
* 使用服务发现
* Eureka
* 消息类型：文档， 命令，事件
* 命令式消息和事件式消息
* 消除同步交互
* 使用异步交互模式
* 复制数据
* 先返回响应，再完成处理

* 使用saga管理事务
* saga的两种不同方式： 一种是协同式(choreography) 另一种是编排式（orchestration)
* 分布式事务的挑战
* 把saga编排器视为一个状态机

* 微服务架构中的业务逻辑设计
* 幸运的是，我们可以使用领域驱动设计中的聚合模式(Aggregate)来解决这些问题。
* 聚合是一组对象，可以作为一个单元来处理。
* 使用聚合可以避免任务跨服务边界的对象引用，因为聚合之间通过主键进行引用，而不是通过对象的地址进行引用
* 由于单个事务只能创建或更新单个聚合，因此聚合满足微服务事务模型的约束
* 使用事务脚本模式设计业务逻辑
* 使用领域模型模式设计业务逻辑
* 关于领域驱动设计：实体，值对象，工厂， 存储库， 服务
* 发布领域事件
* 在命名领域事件时，我们往往选择动词的过去分词。这样的命名能够明确表达事件的一些属性。领域事件的每个属性都是原始值或值对象
* 领域事件通常还具有元数据，如事件id和时间截
* 从概念上讲，领域事件由聚合负责发布

* 使用事件溯源开发业务逻辑
* 事件存储库
* 对象与关系的阻抗失调
* 缺乏聚合的历史
* 实施审计功能将非常烦琐且容易出错
* 事件发布是凌驾于业务逻辑之上
* 事件溯源通过事件来持久化聚合
* 事件代表状态的改变
* 聚合方法都和事件相关
* process apply
* 可靠地发布领域事件
* 保留聚合的历史
* 最大程度地避免对象与关系的“阻抗失调”问题
* 为开发者提供一个“时光机”
* EventStore

* 在微服务架构中实现查询
* 使用api组合模式进行查询
* API Gateway
* 使用CQRS模式
* 使用api组合模式检索分散在多个服务中的数据会导致昂贵、低效的内存中连接
* 拥有数据的服务将数据存储在不能有效支持所需查询的表单或数据库中
* 隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询操作的服务
* CQRS隔离命令和查询
* 它通过订阅由一个或多个其他服务发布的事件来确保它的数据库是不断更新的，并由此实现查询操作
* 这种视图（和它的数据）不属于任何特定服务, 因此将其实现为独立的服务是合理的。
* 在微服务架构中高效地实现查询
* 高效地实现多种不同的查询类型
* 在基于事件溯源技术的应用程序中实现查询
* 更进一步地实现问题隔离
* 不好：更加复杂的架构
* 处理数据复制导致的延迟
* 你应尽可能使用API组合，并在必要时使用CQRS

* 外部API模式
* API gateway模式
* 请求路由
* API组合
* 协议转换
* API Gateway能够为每一个客户端提供它们专用的 API
* 实现边缘功能
* API gateway的架构： API层和公共层
* API gateway的所有者模式
* 使用后端前置模式
* Netflix Falcor是一种api技术
* 性能和可扩展性
* 使用响应式编程抽象编写可维护的代码
* 处理局部故障
* 成为应用程序架构中的好公民
* 使用GraphQL实现API Gateway
* GraphQL api 以模式为中心，模式由一组类型组成，这些类型定义了服务器端数据模型的结构，以及客户端可以执行的操作（如查询）
* 微服务架构中的测试策略
* 单元测试
* 集成测试
* 组件测试
* 端到端测试
* 测试是面向业务还是面向技术
* 测试的目标是协助开发还是寻找产品缺陷
* 测试金字塔
* 消费者驱动的契约测试
* 针对消息传递api的消费者契约测试
* 自动化测试是快速、安全地交付软件的重要基石
* 端到端测试：缓慢、脆弱和昂贵的
* 使用Gherkin编写验收测试
* 设计组件测试

* 开发面向生产环境的微服务应用
* 安全性 可配置性 可观测性
* 使用jwt传递用户身份和角色
* 设计可配置的服务
* 推送模型和拉取模型
* 设计可观测的服务
* 健康检查api
* 日志聚合
* 分布式跟踪
* 异常跟踪
* 应用程序指标
* 审核日志记录
* 使用微服务基底模式开发服务
* 从微服务基底到服务网格

* 部署微服务应用
* 部署包含两个相互关联的概念：流程和架构
* 服务管理接口
* 运行时服务管理
* 监控
* 请求路由
* 部署模式：编程语言特定的发布包格式
* 部署模式：将服务部署为虚拟机
* 部署模式：将服务部署为容器
* 使用服务网格分隔部署与发布流程
* 边车
* 部署模式： serverless部署

* 微服务架构的重构策略
* 绞杀者应用程序（Strangler Application)
* 不要做 一步到位，推倒重来 式的改造
* 推倒重写的唯一保证，就是彻底搞砸一切
* 尽早并且频繁地体现出价值
* 尽可能少对单体做出修改
* 将新功能实现为服务
* 隔离表现层与后端
* 通过将功能提取到服务中来分解单体
* API gateway: 将对新功能的请求路由到新服务，并将遗留请求路由到单体
* 集成胶水代码
