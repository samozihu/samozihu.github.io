---
layout:     post
title:      "领域驱动设计 读后感"
subtitle:   "软件核心复杂性应对之道"
date:       2020-05-16 17:05:00
author:     "aguozhang"
header-img: "img/post-bg-2015.jpg"
tags:
    - DDD 
    - 领域
    - 建模
---

## 前言
久闻大名的一本书， 相见恨晚  
此书需要常常温习  

## 摘录
* 运用领域模型 古代的中国地图
* 它是对现实的解释--把与解决问题密切相关的方面抽象出来，而忽略无关的细节
* 模型和设计的核心互相影响
* 模型是团队所有成员使用的通用语言的中枢
* 模型是浓缩的知识
* 消化知识
* 模型和实现的绑定
* 建立了一种基于模型的语言
* 开发一个蕴含丰富知识的模型
* 提炼模型
* 头脑风暴和实验
* 当开始编写软件时，其实我们所知甚少
* 深层模型
* 知识消化是一种探索，它永无止境
* 交流与语言的使用
* 将模型作为语言的支柱
* 要认识到，UBIQUITOUS LANGUAGE的更改就是对模型的更改
* 大声地建模
* 一个团队，一种语言
* 文档应作为代码和口头交流和补充
* 文档不应再重复表示代码已经明确表达出的内容
* 通过将文档减至最少，并且主要用它来补充代码和口头交流
* 绑定模型与实现
* 模式：Model-Driven Design
* 如果整个程序设计或者其核心部分没有与领域模型相对应，那个这个模型就是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间过于复杂的对应关系也是对于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析和设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享
* 软件系统各个部分的设计应该忠实地反映领域模型，以便体现出这二者之间的明确对应关系。我们应该反复检查并修改模型，以便软件可以更加自然地实现模型，即使想让模型反映出更深层次的领域概念时也应如此。我们需要的模型不但应该满足这两种需求，还应该能够支持健壮的UBIQUITOUS LANGUAGE（通用语言）
* 从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要涉及接下来相应的项目活动
* 完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象的编程
* 提示主旨：为什么模型对用户至关重要
* 模式：Hands-On Modeler
* 任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码
* 模型驱动设计的构造块
* 职责驱动设计 契约式设计
* 模式： LAYERED ARCHITECTURE
* 领域层最重要
* 关注点分离 => 分层的价值
* 领域层是模型的精髓
* 模式： The Smart UI "反模式"
* 如果一个经验并不丰富的项目团队要完成一个简单的项目，却决定使用MODEL-DRIVE DESGIN 以及 LAYERED ARCHITECTURE，那么这个项目组将会经历一个艰难的学习过程。团队成员不得不去掌握复杂的新技术，艰难地学习对象建模。对基础设施和各层的管理工作使得原本简单的任务却要花费很长时间来完成。简单项目的开发周期短，期望值也不高。所以，早在项目团队完成任务之前，该项目就会被取消，更谈不上去认证有关这种方法的许多令人激动的可行性了。
* 即使项目有更充裕的时间，如果没有专家的帮助，团队成员也不太可能掌握这些技术。最后，假如他们确实能够克服这些困难，恐怕也只会开发出一套简单的系统。因为这个项目本来就不需要丰富的功能。
* 软件中所表示的模型
* 模型中每个可遍历的关联，软件中都要有同样属性的机制
* 模式：ENTITY(又称为REFERENCE OBJECT)
* 模型必须定义出“符合什么条件才算是相同的事物”
* ENTITY 建模
* 模式： Value object
* 软件设计要时刻与复杂性做斗争。我们必须区别对待问题，仅在真正需要的地方进行特殊处理。
* 这些是用来描述事物的对象
* 模式：SERVICE
* 有些重要的领域操作无法放到entity或value object中。这当中有些操作从本质上讲是一些活动或动作，而不是事物，但由于我们的建模范式是对象，因此要想办法将它们划归到对象这个范畴里
* 模式：MODULE
* 高内聚，低耦合
* 除非真正有必要将代码分布到不同的服务器上，否则就把实现单一概念对象的所有代码放在同一个模块中（如果不能放在同一个对象中的话）
* 利用打包把领域层从其他代码中分离出来。否则，就尽可能让领域开发人员自由地决定领域对象的打包方式，以便支持他们的模型和设计选择
* 模式：AGGREGATE
* 我们应该将entity与value object分门别类地聚焦到aggregate中，并定义每个aggregate的边界。在每个aggregate中，选择一个entity为根，并通过根来控制边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能绕过它来修复内部对象。这种设计有利于确保aggregate中的对象满足所有固定规则，也可以确保在任何状态变化时aggregate作为一个整体满足固定规则
* 模式：FACTORY
* 模式： REPOSITORY
* 使用语言：一个扩展的示例
* 隔离领域：引用应用层
* 将entity与value object区别开
* 第三部分 通过重构来加深理解
* 如果开发人员能够看准时机，利用成熟的设计模式进行开发，那么 通过重构得到模式 这种方式就可以让重构过程更上一层楼
* 深层模型
* 深层模型/柔性设计
* 突破
* 不要试图去制造突破，那只会使项目陷入困境。通常，只有在实现了许多适度的重构后才有可能出现突破。在大部分时间里，我们都在进行微小的改进，而在这种连续的改进中模型深层含义也会逐渐显现
* 不要犹豫着不去做小的改进
* 将隐式概念转变为显式概念
* 将过程建模为领域对象
* 模式：SPECIFICATION
* 柔性设计
* 很多过度设计（overengineering)借着灵活性的名义而得到合理的外衣
* 模式：INTENTION-REVEALING INTERFACES
* 模式：SIDE-EFFECT-FREE FUNCTION
* 模式：ASSERTION
* 模式：CONCEPTUAL CONTOUR
* 模式：STANDALONE CLASS
* 低耦合是对象设计的一个基本要素。尽一切可能保持低耦合。把其它所有无关概念提取到对象之外。这样类就变得完全独立了，这就使得我们可以单独地研究和理解它。每个这样的独立类都极大地减轻了因理解module而带来的负担
* 模式：CLOSURE OF OPERATION
* 声明式设计
* 领域特定语言
* 声明式设计风格
* 用声明式的风格来扩展SPECIFICATION
* 切入问题的角度
* 应用分析模式
* 分析模式是一种概念集合，用来表示业务建模中的常见结构。它可能只与一个领域有关，也可能跨越多个领域
* 将设计模式应用于模型
* 模式：STRATEGY (也称为POLICY)
* 模式：COMPOSITE
* 通过重构得到更深层的理解
* 以领域为本
* 用一种不同的方式来看待事物
* 始终坚持与领域专家对话
* 与传统重构观点不同的是，即使在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致，或者新需求不能被自然地添加到模型中。重构的原因也可能来自学习：当开发人员通过学习获得了更深刻的理解，从而发现了一个得到更清晰或更有用的模型的机会
* 如何找到问题的病灶往往是最难和最不确定的部分
* 必须始终坚持把“通过重构得到更深层理解”作为这些工作的一部分。因此，当发生以下情况时，就应该进行重构了：
* 设计没有表达出团队对领域的最新理解
* 重要的概念被隐藏在设计中了（而且你已经发现了把它们呈现出来的方法）
* 战略设计
* 保持模型的完整性
* 大型系统领域模型的完全统一即不可行，也不划算
* 模式：BOUNDED CONTEXT
* 模式：CONTINUOUS INTERGRATION
* 模式：CONTEXT MAP
* BOUNDED CONTEX之间的关系
* 模式：SHARED KERNEL
* 模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM
* 模式：CONFORMIST
* 模式：ANTICORRUPTION LAYER
* 创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关功能。这个层通过另一个系统现有接口与其进行对话，而只需要那个系统作出很少的修改，甚至无需修改。在内部，这个层在两个模型之间进行必要的双向转换
* 一个关于防御的故事：长城
* 模式：SEPARATE WAY
* 模式：OPEN HOST SERVICE
* 模式：PUBLISHED LANGUAGE
* 接受那些我们无法更改的事物：描述外部系统
* 转换：合并context: separate way => shared kernel
* 精炼： 模型就是知识的精炼
* 领域模型的战略精炼包括以下部分：
* 帮助所有团队成员掌握系统的总体设计以及各部分如何协调工作
* 找到一个具有适度规模的核心模型并把它添加到通用语言中，从而促进沟通
* 指导重构
* 专注于模型中最有价值的那部分
* 指导外包、现成组件的使用以及任务委派
* 模式：CORE DOMAIN
* 选择核心
* 工作的分配
* 精炼的逐步提升
* 模式：GENERIC SUBDOMAIN
* 模式：DOMAIN VISION STATEMENT
* 模式：HIGHLIGHTED CORE
* 模式： COHESIVE MECHANISM
* 通过精炼得到声明式风格
* 模式： SEGREGATED CORE
* 模式： ABSTRACT CORE
* 首先集中精力把CORE DOMAIN更好地提取出来，完善对core的分离，并且把支持性的子领域提炼成通用子领域
* 大型结构
* 在一个大的系统中，如果因为缺少一种全局性的原则而使人们无法根据元素在模式（这些模式被应用于整个设计）中的角色来解释这些元素，那么开发人员就会陷入“只见树木，不见森林”的境地
* 设计一种应用于整个系统的规则（或角色和关系）模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置（即使是在不知道各个部分的详细职责的情况下）
* 模式：EVOLVING ORDER
* 模式：SYSTEM METAPHOR
* 模式：RESPONSIBILITY LAYER
* 模式： KNOWLEDGE LEVEL
* 模式：PLUGGABLE COMPONENT FRAMEWORK
* 通过重构得到更适当的结构
* 最小化
* 沟通和自律
* 通过重构得到柔性设计
* 通过精炼可以减轻负担
* 领域驱动设计的综合运用
* 3个基本原则：上下文、精炼、大型结构
* 制定战略设计决策的6个要点：
* 决策过程必须收集反馈意见
* 计划必须允许演变
* 架构团队不必把所有最好、最聪明的人员都吸收进来
* 战略设计需要遵守简约和谦逊的原则
* 对象的职责要专一，而开发人员应该是多面手
*聚少成多地成长
 



